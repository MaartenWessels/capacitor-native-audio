{"version":3,"file":"definitions.js","sourceRoot":"","sources":["../../src/definitions.ts"],"names":[],"mappings":"","sourcesContent":["export interface AudioPlayerDefaultParams {\n    /**\n     * Any string to differentiate different audio files.\n     *\n     * @since 1.0.0\n     */\n    audioId: string;\n}\n\nexport interface AudioPlayerPrepareParams extends AudioPlayerDefaultParams {\n    /**\n     * A URI for the audio file to play\n     *\n     * @example A public web source: https://example.com/example.mp3\n     * @since 1.0.0\n     */\n    audioSource: string;\n\n    /**\n     * The album title/name of the audio file to be used on the notification\n     *\n     * @since 2.1.0\n     */\n    albumTitle?: string;\n\n    /**\n     * The artist name of the audio file to be used on the notification\n     *\n     * @since 2.1.0\n     */\n    artistName?: string;\n\n    /**\n     * The title/name of the audio file to be used on the notification\n     *\n     * @since 1.0.0\n     */\n    friendlyTitle: string;\n\n    /**\n     * Whether to use this audio file for the notification.\n     * This is considered the primary audio to play.\n     *\n     * It must be created first and you may only have one at a time.\n     *\n     * @default false\n     * @since 1.0.0\n     */\n    useForNotification: boolean;\n\n    /**\n     * A URI for the album art image to display on the Android/iOS notification.\n     *\n     * Can also be an in-app source. Pulls from `android/app/src/assets/public` and `ios/App/App/public`.\n     * If using [Vite](https://vitejs.dev/guide/assets.html#the-public-directory),\n     * you would put the image in your `public` folder and the build process will copy to `dist`\n     * which in turn will be copied to the Android/iOS assets by Capacitor.\n     *\n     * A PNG is the best option with square dimensions. 1200 x 1200px is a good option.\n     *\n     * @example A public web source: https://example.com/artwork.png\n     * @example An in-app source: images/artwork.png\n     * @since 1.0.0\n     */\n    artworkSource?: string;\n\n    /**\n     * Is this audio for background music/audio.\n     *\n     * Should not be `true` when `useForNotification = true`.\n     *\n     * @default false\n     * @since 1.0.0\n     */\n    isBackgroundMusic?: boolean;\n\n    /**\n     * Whether or not to loop other audio like background music\n     * while the primary audio (`useForNotification = true`) is playing.\n     *\n     * @default false\n     * @since 1.0.0\n     */\n    loop?: boolean;\n\n    /**\n     * Whether or not to show the seek backward button on the OS's notification.\n     * Only has affect when `useForNotification = true`.\n     *\n     * @default true\n     * @since 1.2.0\n     */\n    showSeekBackward?: boolean;\n\n    /**\n     * Whether or not to show the seek forward button on the OS's notification.\n     * Only has affect when `useForNotification = true`.\n     *\n     * @default true\n     * @since 1.2.0\n     */\n    showSeekForward?: boolean;\n\n    /**\n     * The URL to fetch metadata updates at the specified interval. Typically used for a radio stream.\n     * See the section on [Metadata Updates](#metadata-updates) for more info.\n     * Only has affect when `useForNotification = true`.\n     *\n     * @since 2.2.0\n     */\n    metadataUpdateUrl?: string;\n\n    /**\n     * The interval to fetch metadata updates in seconds.\n     *\n     * @default 15\n     * @since 2.2.0\n     */\n    metadataUpdateInterval?: number;\n}\n\nexport interface AudioPlayerListenerParams {\n    /**\n     * The `audioId` set when `create` was called.\n     *\n     * @since 1.0.0\n     */\n    audioId: string;\n}\n\nexport interface AudioPlayerListenerResult {\n    callbackId: string;\n}\n\nexport interface AudioPlayerMetadataUpdateListenerEvent {\n    /**\n     * The album title\n     *\n     * @since 2.2.0\n     */\n    album_title: string;\n\n    /**\n     * The artist name\n     *\n     * @since 2.2.0\n     */\n    artist_name: string;\n\n    /**\n     * The song title\n     *\n     * @since 2.2.0\n     */\n    song_title: string;\n\n    /**\n     * A URI for the album art image to display on the Android/iOS notification.\n     *\n     * @since 2.2.0\n     */\n    artwork_source: string;\n}\n\nexport interface AudioPlayerPlugin {\n    /**\n     * Create an audio source to be played.\n     *\n     * @since 1.0.0\n     */\n    create(params: AudioPlayerPrepareParams): Promise<{ success: boolean }>;\n\n    /**\n     * Initialize the audio source. Prepares the audio to be played, buffers and such.\n     *\n     * Should be called after callbacks are registered (e.g. `onAudioReady`).\n     *\n     * @since 1.0.0\n     */\n    initialize(params: AudioPlayerDefaultParams): Promise<{ success: boolean }>;\n\n    /**\n     * Start native-level tracking of audio playback progress.\n     * Tracks individual seconds of audio that are actually played (not skipped or seeked over).\n     * Useful for analytics, progress tracking, or when JavaScript execution may be limited.\n     *\n     * @since 3.0.0\n     */\n    startBackgroundTracking(params: AudioPlayerDefaultParams & { duration: number }): Promise<void>;\n\n    /**\n     * Stop native-level tracking of audio playback progress.\n     * Call this when you no longer need to track playback seconds natively.\n     *\n     * @since 3.0.0\n     */\n    stopBackgroundTracking(params: AudioPlayerDefaultParams): Promise<void>;\n\n    /**\n     * Retrieve and clear the collected playback progress data.\n     * Returns an array of unique second timestamps that were actually played (excluding skipped content).\n     * The data is automatically cleared after fetching to prevent duplicate reporting.\n     *\n     * @since 3.0.0\n     */\n    fetchBackgroundPlayedSeconds(params: AudioPlayerDefaultParams): Promise<{ seconds: number[] }>;\n\n    /**\n     * Change the audio source on an existing audio source (`audioId`).\n     *\n     * This is useful for changing background music while the primary audio is playing\n     * or changing the primary audio before it is playing to accommodate different durations\n     * that a user can choose from.\n     *\n     * @since 1.0.0\n     */\n    changeAudioSource(params: AudioPlayerDefaultParams & { source: string }): Promise<void>;\n\n    /**\n     * Change the associated metadata of an existing audio source\n     *\n     * @since 1.1.0\n     */\n    changeMetadata(\n        params: AudioPlayerDefaultParams & {\n            albumTitle?: string;\n            artistName?: string;\n            friendlyTitle?: string;\n            artworkSource?: string;\n        },\n    ): Promise<void>;\n\n    /**\n     * Update metadata from Update URL\n     *\n     * This runs async on the native side. Use the `onMetadataUpdate` listener to get the updated metadata.\n     *\n     * @since 2.2.0\n     */\n    updateMetadata(params: AudioPlayerDefaultParams): Promise<void>;\n\n    /**\n     * Get the duration of the audio source.\n     *\n     * Should be called once the audio is ready (`onAudioReady`).\n     *\n     * @since 1.0.0\n     */\n    getDuration(params: AudioPlayerDefaultParams): Promise<{ duration: number }>;\n\n    /**\n     * Get the current time of the audio source being played.\n     *\n     * @since 1.0.0\n     */\n    getCurrentTime(params: AudioPlayerDefaultParams): Promise<{ currentTime: number }>;\n\n    /**\n     * Play the audio source.\n     *\n     * @since 1.0.0\n     */\n    play(params: AudioPlayerDefaultParams): Promise<void>;\n\n    /**\n     * Pause the audio source.\n     *\n     * @since 1.0.0\n     */\n    pause(params: AudioPlayerDefaultParams): Promise<void>;\n\n    /**\n     * Seek the audio source to a specific time.\n     *\n     * @since 1.0.0\n     */\n    seek(params: AudioPlayerDefaultParams & { timeInSeconds: number }): Promise<void>;\n\n    /**\n     * Stop playing the audio source and reset the current time to zero.\n     *\n     * @since 1.0.0\n     */\n    stop(params: AudioPlayerDefaultParams): Promise<void>;\n\n    /**\n     * Set the volume of the audio source. Should be a decimal less than or equal to `1.00`.\n     *\n     * This is useful for background music.\n     *\n     * @since 1.0.0\n     */\n    setVolume(params: AudioPlayerDefaultParams & { volume: number }): Promise<void>;\n\n    /**\n     * Set the rate for the audio source to be played at.\n     * Should be a decimal. An example being `1` is normal speed, `0.5` being half the speed and `1.5` being 1.5 times faster.\n     *\n     * @since 1.0.0\n     */\n    setRate(params: AudioPlayerDefaultParams & { rate: number }): Promise<void>;\n\n    /**\n     * Wether or not the audio source is currently playing.\n     *\n     * @since 1.0.0\n     */\n    isPlaying(params: AudioPlayerDefaultParams): Promise<{ isPlaying: boolean }>;\n\n    /**\n     * Destroy all resources for the audio source.\n     * The audio source with `useForNotification = true` must be destroyed last.\n     *\n     * @since 1.0.0\n     */\n    destroy(params: AudioPlayerDefaultParams): Promise<void>;\n\n    /**\n     * Register a callback for when the app comes to the foreground.\n     *\n     * @since 1.0.0\n     */\n    onAppGainsFocus(\n        params: AudioPlayerListenerParams,\n        callback: () => void,\n    ): Promise<AudioPlayerListenerResult>;\n\n    /**\n     * Registers a callback from when the app goes to the background.\n     *\n     * @since 1.0.0\n     */\n    onAppLosesFocus(\n        params: AudioPlayerListenerParams,\n        callback: () => void,\n    ): Promise<AudioPlayerListenerResult>;\n\n    /**\n     * Registers a callback for when the audio source is ready to be played.\n     *\n     * @since 1.0.0\n     */\n    onAudioReady(\n        params: AudioPlayerListenerParams,\n        callback: () => void,\n    ): Promise<AudioPlayerListenerResult>;\n\n    /**\n     * Registers a callback for when the audio source has ended (reached the end of the audio).\n     *\n     * @since 1.0.0\n     */\n    onAudioEnd(\n        params: AudioPlayerListenerParams,\n        callback: () => void,\n    ): Promise<AudioPlayerListenerResult>;\n\n    /**\n     * Registers a callback for when state of playback for the audio source has changed by external controls.\n     * This should be used to update your UI when the notification/external controls are used to control the playback.\n     *\n     * On Android, this also gets fired when your app changes the state (e.g. by calling `play`, `pause` or `stop`)\n     * due to a limitation of not knowing where the state change came from, either the app or the `MediaSession` (external controls).\n     *\n     * It may be fixed in the future for Android if a solution is found so don't rely on it when your app itself changes the state.\n     *\n     * @since 1.0.0\n     */\n    onPlaybackStatusChange(\n        params: AudioPlayerListenerParams,\n        callback: (result: { status: 'playing' | 'paused' | 'stopped' }) => void,\n    ): Promise<AudioPlayerListenerResult>;\n\n    /**\n     * Registers a callback for when metadata updates from a URL.\n     *\n     * It will return all data from the URL response, not just the required data. So you could have the metadata endpoint return other data that you may need.\n     *\n     * @since 2.2.0\n     */\n    onMetadataUpdate(\n        params: AudioPlayerListenerParams,\n        callback: (result: AudioPlayerMetadataUpdateListenerEvent) => void,\n    ): Promise<AudioPlayerListenerResult>;\n}\n"]}